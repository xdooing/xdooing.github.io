---
title: 工作记录
date: 2024-05-29 00:00:00 +0800
categories: [工作记录]
tags: [编程]
pin: true


toc: true
comments: true

math: false
mermaid: true

typora-root-url: ../../xdooing.github.io

---



> 本篇用于记录工作中的琐碎知识点，便于随手查阅，空闲时间可以整理。



# 0.待学习

- [ ] 看一下CRC，循环冗余校核，看看怎么用
- [ ] 多线程编程中的缓存一致性，做笔记
- [x] 关于异常捕获：try catch，要学会
- [ ] 内存池，公司的项目会有自己的内存管理，找时间搞懂
- [x] 编译的module和module hash是什么
- [x] 归并排序
- [ ] python脚本语言
- [ ] 正则表达式
- [ ] 书：《C++多核高级编程》
- [x] 学会cmake
- [ ] C++ memory cache相关，如何进行缓存的
- [x] 内存对齐与缓存伪共享`__attribute__((__aligned__(64)))`
- [ ] TCL脚本编程（优先级不高）



# 0.待解决

- [ ] cell 或者 inst 被实例化多次被意味着什么？基于refCount的判断到处都是（例如尚未flatten时merge wire，hierCell实例化2次及以上才会进行）。
- [ ] tech中的`layer_model_vec.size()`与GUI中显示的layer层数为何不一致。
- [x] pin的port是啥格式的，portNum数量有何意义。
- [ ] 源码中各种方向的意义是什么，方向不同时，为什么处理方式不同。
- [ ] port相关的什么rect index，group是什么意思
- [ ] std cell为什么是根据height的数量进行判断的，而不是直觉上的根据文档中的定义来判断的。







# 1. EDA记录

## 基本知识点

### 1.1 寄生参数提取

**定义**

在电子设计自动化（EDA）中，寄生提取（PEX）是计算电子电路的设计器件和所需布线互连线中的寄生效应：**寄生电容，寄生电阻和寄生电感**，通常称为寄生器件，寄生元件或简单的寄生元件。

寄生提取的主要目的是建立一个精确的电路模拟模型，使详细的模拟能够模拟实际的数字和模拟电路响应。 数字电路响应通常用于填充数据库，用于信号延迟和加载计算，如：时序分析，电源分析，电路模拟以及信号完整性分析。

**参数提取的两种策略**

- **基于场求解器**：

  > 从麦克斯韦方程的某种变体形式出发来求解电路中的电磁场，直接从中得到电路的寄生参数(电阻、电容等)，其理论清晰，从而精确可靠，但因求解实际集成电路版图上的麦克斯韦方程需要的计算量巨大，使其无法运用到真实的集成电路设计上。

  这种策略中，通过求解麦克斯韦方程来计算寄生电阻（R），寄生电容（C），寄生电感（L），称为3D提取，是一种高精度的方法，但也需要更强的处理能力，不用于全芯片的提取，可以使用有限元或随机游走算法 -- 在处理时间和精度之间进行权衡，有限元算法更精确。

- **基于模型匹配技术**：

  > 对预先定义的一些电路模型建立寄生参数库，然后通过对实际的电路与模型的匹配来取得寄生参数，在实际版图的提取中有较高的效率，从而在今工业界得到广泛的应用，但是因不可能预先定义电路版图中所有可能出现的模型，故在新的工艺下基于模型匹配的寄生参数提取精确度与可靠性不足。国内外占寄生参数提取市场主导地位的是synopsys的 **StarRC**，cadence的 **QRC** 和mentor的calibre **XRC**，它们都是基于模型匹配提取技术的，共占有整个寄生参数提取市场份额的95％。这些软件工具基本能够满足以前的集成电路工艺制程下寄生参数提取的要求。

  基于模型匹配的策略中，则是使用一张查找表来计算寄生R或C，这种方法称为2D或2.5D提取。支持全芯片提取。

关于PEX，itf/ict文件是sc两家的互连工艺格式文件。是工艺参数文件。记录了每层材料的电阻率、介电常数、温度系数、最小宽度等详细信息。EDA工具没有直接使用这类文件进行RC的抽取，因为计算量是巨大的，将严重影响EDA工具的速度。

互连线工艺文件，主要包括：

- 工艺参数：比如金属的厚度，金属层的方块电阻值，介质层的厚度，介质层的介电常数等
- 工艺效应系数和PVT系数：比如线宽增大效应，温度系数等



### 1.2 IR-Drop

**定义**

IR drop是指在集成电路中电源和地网络上电压下降或升高的一种现象。随着半导体工艺的不断演进，金属互连线的宽度越来越窄，电阻不断变大（供电电压也越来越小），IR drop的效应越来越明显。因此，现在的芯片最后都把IR drop分析作为芯片sign off的一个必要步骤。

**种类**

IR drop主要分为两种。静态和动态的

静态IR drop现象产生的原因主要是电源网络的金属连线的分压，是由于金属连线的自身电阻分压造成的。电流经过内部电源连线的时候产生电源压降。所以静态IR drop主要跟电源网络的结构和连线细节有关。因此静态IR drop主要考虑电阻效应，分析电阻的影响即可。

动态IR drop是电源在电路开关切换的时候电流波动引起的电压压降。这种现象产生在时钟的触发沿，时钟沿跳变不仅带来自身的大量晶体管开关，同时带来组合逻辑电路的跳变，往往在短时间内在整个芯片上产生很大的电流，这个瞬间的大电流引起了IR drop现象。同时开关的晶体管数量越多，越容易触发动态IR drop现象。

在项目前期，由于数字后端实现的database没有ready，后仿可能也没有时间做，所以此时动态IR Drop的分析一般都是基于Vectorless。而项目后期都是需要基于某个场景下，比如max power，去产生对应的VCD，然后再去做基于VCD的动态IR drop分析。基于VCD动态IR drop的分析一般可以不指定各个子模块的功耗值，工具可以从VCD中获取对应的power值，如果没有对应的功耗值，则采用用户设置的值。

**影响**

电压降低后，gate的开关速度变慢，性能降低。因此，对于高性能的设计，必须将IR Drop控制在很小的范围内。芯片功能错误在极端的情况下功能也会受影响的。在深亚微米下，如果power network做的不够好，然后碰上了很不好的case，IR drop在某个局部区域特别大（特别是动态IR drop），从而导致STA阶段signoff的timing 与实际情况不一致（考虑OCV仍然无法cover design的要求），导致setup或者hold的违例。setup的违例，可以通过抬高电压来提升频率，但是代价是功耗上去了，而且如果动态IR drop不够robust，可能通过抬电压，setup能提升的空间也有限。而一旦出现hold违例，那芯片就无法正常工作。因此在先进工艺中，IR drop的影响特别大，需要引起各位的高度重视。

**改善方法**

提高power mesh密度增加power switch cell 数量插足够多的decap cell（含decoupling capacitance）将同时翻转的寄存器摊开些摆放



### 1.3 各种文件

#### ITF文件

> 后端设计中，我们需要知道每条net的RC值来计算timing，RC由process直接决定，不同的导体/绝缘体材料、金属宽度/厚度/间距、制造过程中的光刻/刻蚀/抛光等引起的工艺偏差、工作温度等因素都会导致RC变化。
> Foundary会考虑制造过程中的种种因素，建立RC模型，来提供给后端；后端根据此模型，抽取计算得到整条net的RC，继而得出net timing。
> Foundary提供的process RC有三种格式：itf，TLU+，nxtgrd；三者可以通过Starrc相互转换。

- **ITF structure**

  三种格式中，itf file是可读的，我们下面就看一下它的内容。
  ITF是按芯片的横截面来描述的，从最上层的绝缘层开始，逐层向下描述。ITF文件结构如下：

  ```
  TECHNOLOGY = process_name
  REFERENCE_DIRECTION = VERTICAL | HORIZONTAL | GATE
  [GLOBAL_TEMPERATURE = temp_value]
  [BACKGROUND_ER = value]
  [HALF_NODE_SCALE_FACTOR = scale_factor]
  [USE_SI_DENSITY = YES | NO ]
  [DROP_FACTOR_LATERAL_SPACING = value]
  
  DIELECTRIC top_dielectric_name {…}
  CONDUCTOR top_conductor_name {…}
  […]
  [DIELECTRIC bottom_dielectric_name{…}]
  
  VIA top_via_name {…}
  […]
  VIA bottom_via_name {…}
  ```

  文件最上方为process technology的整体描述，接着是DIELECTRIC/CONDUCTOR的逐层描述，最后是VIA部分。

- **Example of TSMC28HPC+ ITF**

  下面结合以TSMC的ITF中的M8为例，来详细解析一下。

  ```
  $$ 省略文件头和AP,M8比较有代表性。
  $$ PS:itf中用$注释
  DIELECTRIC PASS2 	 {THICKNESS=0.668210	ER=4.2 } 
  DIELECTRIC PASS1 	 {THICKNESS=0.071590	ER=7.1 } 
  DIELECTRIC IMD8c 	 {THICKNESS=0.778950	ER=4.2 } 
  DIELECTRIC IMD8b 	 {THICKNESS=0.051500	ER=7.1 } 
  DIELECTRIC IMD8a_A 	 {THICKNESS=0.055000	ER=4.2 } 
  $$ 上面5行说明AP/M8之间有5层绝缘层，THICKNESS为该层厚度，ER为该层相对介电常数ε。
  $$ 介电常数ε也被称为电容率，理想金属导体的ε应该是正无穷。
  $$ 金属导线的cap值就是和这些绝缘层的ε有关。
  CONDUCTOR M8 {THICKNESS= 0.885450
      CRT1=3.890e-03 CRT2=-1.500e-07 
  	$$ 这两个值用来计算temperature variation时的电阻， temperature-dependent resistance 为T的二次多项式，如下：
  	$$ R= CRT2*(T-T0)^2 + CRT1*(T-T0) + R0
      SIDE_TANGENT = 0.046869 
  	$$ 理想情况下，金属层的截面应该是规则矩形，但是沉积过程引起的偏差，可能会导致截面为梯形（上宽下窄或上窄下宽）
  	$$ SIDE_TANGENT指的就是截面斜边偏移角度的正切值(tanΘ)；正值表示上宽下窄，负值表示上窄下宽
  	$$ 这里，我们可以计算得出M8截面是个底角2.68°的上宽下窄的梯形。
      POLYNOMIAL_BASED_THICKNESS_VARIATION {
  	$$ 这部分描述的是工艺过程中M8后端偏差，该值是基于density和width的多项式
           DENSITY_POLYNOMIAL_ORDERS  { 4, 3, 2, 1, 0 }
  		 $$ 多项式中density的指数
           WIDTH_POLYNOMIAL_ORDERS  { 4, 3, 2, 1, 0 }
  		 $$ 多项式中width的指数
           WIDTH_RANGES {0.9 10.8000}
  		 $$ width分布，这里有两个值，所以下面的多项式系数有三组，分别对应width<=0.9, 0.9<width<10.8, width>10.8的情况
           POLYNOMIAL_COEFFICIENTS  {
               0    -2.09675E+01    4.71013E+01    -3.63903E+01    1.10754E+01  
               0    2.24127E+01    -5.02114E+01    3.88210E+01    -1.28144E+01  
               0    -7.76371E+00    1.73158E+01    -1.32161E+01    5.02100E+00  
               0    9.83830E-01    -2.18583E+00    1.54960E+00    -8.13606E-01  
               0    -3.44482E-02    7.69210E-02    -3.26943E-02    5.70675E-02  
           }
           $$ 多项式的系数，因为上面density/width指数都有5种，所以多项式有5*5=25项，表格分别为每项的指数，具体为：
           $$ delta_thickness = 
           $$     0 * D^4W^4  +  -2.09675E+01 * D^3W^4 +  4.71013E+01 * D^2W^4  +  -3.63903E+01 * D^1W^4 +  1.10754E+01 * D^0W^4 
           $$     0 * D^4W^3  +  2.24127E+01  * D^3W^3 + -5.02114E+01 * D^2W^3  +  3.88210E+01  * D^1W^3 + -1.28144E+01 * D^0W^3 
           $$     0 * D^4W^2  +  -7.76371E+00 * D^3W^2 +  1.73158E+01 * D^2W^2  +  -1.32161E+01 * D^1W^2 +  5.02100E+00 * D^0W^2 
           $$     0 * D^4W^1  +  9.83830E-01  * D^3W^1 + -2.18583E+00 * D^2W^1  +  1.54960E+00  * D^1W^1 + -8.13606E-01 * D^0W^1 
           $$     0 * D^4W^0  +  -3.44482E-02 * D^3W^0 +  7.69210E-02 * D^2W^0  +  -3.26943E-02 * D^1W^0 +  5.70675E-02 * D^0W^0 
  		  
           POLYNOMIAL_COEFFICIENTS  {
               8.60236E-04    -2.58636E-02    1.86404E-01    -6.33564E-01    1.60353E+00  
               -2.01704E-03    6.46872E-02    -4.28490E-01    1.02433E+00    -3.01753E+00  
               1.99839E-03    -6.92845E-02    4.59826E-01    -7.29301E-01    2.14093E+00  
               -9.64384E-04    3.62202E-02    -2.60733E-01    3.44576E-01    -7.69564E-01  
               1.81498E-04    -7.35529E-03    5.84458E-02    -7.00805E-02    1.21186E-01  
           }
           POLYNOMIAL_COEFFICIENTS  {
               0    0    0    0    0  
               0    0    0    0    0  
               0    0    0    0    0  
               0    0    0    0    0  
               0    0    0    0    0.060929
           }
      }
      RHO_VS_SI_WIDTH_AND_THICKNESS {
  	$$ 这部分表示体电阻率(bulk resistivity)，该值是基于width和thickness查表得到
           WIDTH   { 0.3240 0.3600 0.3960 0.4320 0.4680 0.5400 0.7200 1.0800 1.3500 1.8000 2.7000 3.6000 4.5000 5.4000 6.7500 8.1000 9.0000 10.8000 }
           THICKNESS   { 0.5950 0.6800 0.7650 0.8500 0.9350 1.0200 1.1050 1.1900 1.2750 }
           VALUES  { 
   0.0206 0.0204 0.0202 0.0201 0.0200 0.0198 0.0196 0.0193 0.0192 0.0191 0.0190 0.0189 0.0189 0.0189 0.0189 0.0189 0.0189 0.0189
   0.0205 0.0203 0.0202 0.0201 0.0200 0.0198 0.0195 0.0192 0.0191 0.0190 0.0189 0.0188 0.0188 0.0188 0.0188 0.0188 0.0188 0.0188
   0.0205 0.0203 0.0201 0.0200 0.0199 0.0197 0.0195 0.0192 0.0191 0.0189 0.0188 0.0188 0.0188 0.0187 0.0187 0.0187 0.0187 0.0187
   0.0204 0.0202 0.0201 0.0200 0.0199 0.0197 0.0194 0.0191 0.0190 0.0189 0.0188 0.0187 0.0187 0.0187 0.0187 0.0187 0.0187 0.0186
   0.0204 0.0202 0.0201 0.0199 0.0198 0.0197 0.0194 0.0191 0.0190 0.0189 0.0187 0.0187 0.0187 0.0186 0.0186 0.0186 0.0186 0.0186
   0.0204 0.0202 0.0200 0.0199 0.0198 0.0196 0.0194 0.0191 0.0189 0.0188 0.0187 0.0187 0.0186 0.0186 0.0186 0.0186 0.0186 0.0186
   0.0204 0.0202 0.0200 0.0199 0.0198 0.0196 0.0193 0.0190 0.0189 0.0188 0.0187 0.0186 0.0186 0.0186 0.0185 0.0185 0.0185 0.0185
   0.0203 0.0202 0.0200 0.0199 0.0198 0.0196 0.0193 0.0190 0.0189 0.0188 0.0187 0.0186 0.0186 0.0185 0.0185 0.0185 0.0185 0.0185
   0.0203 0.0201 0.0200 0.0199 0.0198 0.0196 0.0193 0.0190 0.0189 0.0188 0.0186 0.0186 0.0185 0.0185 0.0185 0.0185 0.0185 0.0185
             }
         }
      ETCH_VS_WIDTH_AND_SPACING  {
  	$$ 这部分表示刻蚀宽度偏差。理想情况下，刻蚀的宽度就是mask留的宽度，但实际制造中，光刻和刻蚀会受到线宽和间距影响而引起偏差
  	$$ 因此，实际的线宽应该是理想线宽减去两倍的刻蚀偏差，real_width=origin-2*etch_value
  	$$ etch_value为正值时，说明线宽变窄，shrink; etch_value为负值时，说明线宽变宽，expansion
  	$$ 实际线上电阻应该基于考虑etch后的真实线宽
  	$$ etch_value通过spacing和width查表得到
           SPACINGS { 0.3600 0.5400 0.7200 0.9000 1.0800 1.3500 1.8000 2.2500 2.7000 3.1500 3.6000 4.0500 4.5000 4.9500 5.4000 }
           WIDTHS   { 0.3600 0.5400 0.7200 0.9000 1.0800 1.3500 1.8000 2.7000 3.6000 4.5000 5.4000 6.7500 8.1000 9.0000 10.8000 }
           VALUES  { 
   -0.023150 -0.022300 -0.021450 -0.020650 -0.019800 -0.018950 -0.018100 -0.017300 -0.016450 -0.015600 -0.014800 -0.013950 -0.013100 -0.012250 -0.011450
   -0.014300 -0.013100 -0.011900 -0.010700 -0.009500 -0.008350 -0.007150 -0.006000 -0.004800 -0.003600 -0.002450 -0.001200 -0.000050 0.001150 0.002300
   -0.001000 0.000250 0.001500 0.002750 0.004050 0.005300 0.006550 0.007800 0.009100 0.010350 0.011600 0.012900 0.014150 0.015400 0.016650
   0.008950 0.010350 0.011700 0.013100 0.014550 0.015900 0.017300 0.018700 0.020100 0.021500 0.022900 0.024250 0.025650 0.027050 0.028450
   -0.005550 -0.004300 -0.003050 -0.001800 -0.000500 0.000750 0.002000 0.003250 0.004500 0.005750 0.007000 0.008250 0.009550 0.010750 0.012050
   -0.001700 -0.000150 0.001450 0.002950 0.004500 0.006100 0.007650 0.009250 0.010800 0.012350 0.013900 0.015450 0.017000 0.018550 0.020150
   -0.035000 -0.032850 -0.030650 -0.028500 -0.026350 -0.024200 -0.022050 -0.019900 -0.017700 -0.015550 -0.013400 -0.011250 -0.009050 -0.006900 -0.004750
   -0.039750 -0.036550 -0.033350 -0.030150 -0.026950 -0.023700 -0.020500 -0.017300 -0.014050 -0.010850 -0.007650 -0.004400 -0.001200 0.002000 0.005200
   -0.032350 -0.028100 -0.023850 -0.019600 -0.015400 -0.011150 -0.006900 -0.002650 0.001600 0.005800 0.010050 0.014300 0.018500 0.022800 0.027050
   -0.025800 -0.020500 -0.015250 -0.010000 -0.004750 0.000550 0.005850 0.011100 0.016350 0.021650 0.026900 0.032200 0.037450 0.042750 0.048000
   -0.015900 -0.009600 -0.003350 0.002950 0.009250 0.015550 0.021800 0.028150 0.034400 0.040700 0.047000 0.053300 0.059550 0.065850 0.072150
   -0.007650 0.000200 0.008050 0.015900 0.023700 0.031550 0.039400 0.047250 0.055100 0.062900 0.070800 0.078600 0.086450 0.094300 0.102150
   0.005350 0.014700 0.024100 0.033450 0.042850 0.052200 0.061600 0.070950 0.080350 0.089750 0.099100 0.108500 0.117850 0.127250 0.136600
   -0.011200 -0.000750 0.009700 0.020150 0.030600 0.041050 0.051500 0.062000 0.072450 0.082900 0.093350 0.103850 0.114300 0.124750 0.135200
   -0.001550 0.011000 0.023500 0.036050 0.048550 0.061100 0.073600 0.086150 0.098700 0.111200 0.123700 0.136250 0.148750 0.161300 0.173800
             }
         }
   WMIN=0.36 SMIN=0.36 
   $$ WMIN为min width；SMIN为min spacing
   CRT_VS_SI_WIDTH {
   $$ 上面说过temperature-dependent resistance，两个系数分别为CRT1和CRT2
   $$ CRT1/CRT2基于width查一维表得到
    (0.3900, 3.6490e-03, -8.5347e-07)  (0.4572, 3.6834e-03, -8.5317e-07)  (0.5520, 3.7122e-03, -8.2474e-07)  (0.7000, 3.7416e-03, -8.9018e-07)  (1.0630, 3.7820e-03, -9.4955e-07)  (1.3347, 3.7960e-03, -7.8620e-07)  (4.4036, 3.8055e-03, -4.7080e-07)  (6.5707, 3.8055e-03, -4.7080e-07)
   }
  }
  ```

- **conclusion**

  芯片制造过程中的工艺偏差，会导致金属的宽度/厚度/形状发生偏差，继而导致RC的偏差。

  ```
  thickness = origin - f(density,width)
  width = origin - 2*f(spacing,width)
  resistivity = f(width,thickness)
  R= CRT2*(T-T0)^2 + CRT1*(T-T0) + R0
  ```


### 1.4 Re-distributed layer

> 参考链接（内有图片示意）：https://xueqiu.com/8635982927/244221029?_ugc_source=ugcbaiducard

RDL（重布线层Re-distributed layer）主要为2D平面上的芯片电气延伸与互连提供媒介。芯片的I/O触点通常分布在边沿或者四周，直接进行芯片倒装会因缺少引线或引线过于密集而导致连接受限，RDL则可将这些触点重新布局到占位更为宽松的区域，并形成面阵列排布，以此减少后续的封装或表面贴装的难度

RDL的优势主要有3点：

- 芯片设计者可以通过对RDL的设计代替一部分芯片内部线路的设计，从而降低设计成本
- 采用RDL能够支持更多的引脚数量
- 采用RDL可以使I/O触点间距更灵活、凸点面积更大，从而使基板与元件之间的应力更小、元件可靠性更高。

RD在晶圆级封装、面板级封装以及立体堆叠封装中有广泛的应用。根据重布凸点的位置，RDL可分为扇入型（Fan-In）和扇出型（Fan-Out）。扇入型封装是将线路集中在芯片内部，主要用于低I/O节点数量和较小裸片工艺中；扇出型封装技术采用在芯片尺寸以外的区域做I/O接点布线设计以提高I/O接点的数量。



### 1.5 Passivation工艺流程(钝化)

> 参考链接：https://zhuanlan.zhihu.com/p/279152231?utm_id=0

三个专有名词

- **RV** : Redistribution Via, 形成孔，联通上层的APL层与下层的Top Metal层
- **APL** : Aluminum Pad Layer，芯片的金属接点，主要材料为铝，连接外部的电路
- **CB** : Chip Barrier，用于保护芯片

芯片分层示意中的AP层和RV层就是这个意思





## icpower

### 逻辑梳理

**1.move Equivalent nets**

> 【AI】在芯片设计中，"Equivalent net"（等效网络）是指逻辑上功能和性能相同，但结构可能不同的电路网络。设计过程中采用等效网络的概念，可以实现复杂电路设计的简化，提高电路设计的效率。这种方法通常运用在各种技术中，例如最小化门电路，逻辑电路简化等。

简单来说，就是import design之后，需要将指定master net的等效net中的Route，Term，Pin转移到master net中，方式为：

- 转移Route：转移之后把equivalent net中的Route清除掉，但是需要注意的是，转移就行，但是似乎不需要将原本的route的type设置成master net的type。
- 转移Term：将term的id置为NULL_ID，然后将其转移到master net中，最后清除掉原来的。
- 转移Pin：转移之后删掉原来的就好了。















### 基本概念总结

> - **Cell : Form LEF Macro**
>   - Cell info: Name,Width , Height, Term, Lib, Term, PGTerm
> - **Inst : Instantiated from cell** **（Def component）**
>   - Inst info: Name, HierName, Location, CellType, Box, Orientation, PR Status, PIN, PGPin
> - **HierarchyCell**
>   - 把Module 定义为一个Design X， DesignX 有自己的def， DesignX 被称为Hierarchy Cell，Design X 在 可以在Top Module中被调用
> - **HierarchyInst**
>   - 在Top Module 被实例化的DesignX 被称为HierarchyInst

------

> - Master(Reference)
>   - Master 指的是被实例化的模板， 比如 Inst的Master 是Cell， Pin的master 是Term， 在有的工具中也交reference
> - Parent（Owner）
>   - Parent 指的是某个object 的所拥有者，比如一个Pin属于哪个Instance， 那么他的Parent 就是Instance， 有的工具中把parent 也叫owner





#### 1.Cell

- Decap Cell : 

  > 去耦单元，这是一种特殊的Filler Cell。当电路中大量单元同时翻转时会导致冲放电瞬间电流增大，使得电路动态供电电压下降或者地线电压升高，引起动态电压降，称为IR Drop。为了避免IR Drop对电路性能的影响，通常在电源和地线之间放置由MOS管构成的电容，这种电容被称为去耦电容或者去耦单元，它的作用是在瞬态电流增大，电压下降时向电路补充电流以保持电源和地线之间的电压稳定，防止电源线的电压降和地线电压升高。

- Leaf Cell :

  > 在design中，instance的设计，称为Cell。没有子模块的cell统称为leaf cell

- lead Cell

  > 芯片引脚（Lead）: 是指芯片上用于传输信号和供电的金属接触点。这些引脚位于芯片的边缘周围，通过焊接或插入连接到电子电路板或其他器件上。每个引脚代表一个特定的电子功能或信号，并且它们的数量和排列方式因芯片类型和设计而异，总之扮演着联系和连接芯片内部电路与外部器件的重要角色。
  >
  > “lead cell”通常指的是连接引脚和内部逻辑单元的单元。这些单元用于将内部逻辑连接到芯片的外部引脚，从而使得芯片能够与外部电路进行通信。具体来说，lead cell可能包括输入/输出缓冲器、驱动器、去抖动缓冲器等。这些单元在设计时需要考虑其性能、功耗、驱动能力以及与外部电路的兼容性等因素。在芯片设计中，lead cell的选择和布局是非常重要的，它们需要满足芯片的电气和物理要求，同时还需要考虑生产和测试的要求。

- std Cell

  > Standard cell是一个预定义的电子元件，包括一些常用的数字逻辑门、触发器、多路复用器等，都绘制在一定的尺寸和形状的区域中，并具有特定的输入输出位置。这些元件形成了一个库，可以在设计集成电路时进行复用。使用Standard Cell可以大大缩短设计时间，也简化了设计流程。

- quasi std Cell

  > Quasi Standard cell则是介于标准单元和全自定义设计之间的一种设计方法。它以标准单元为基础，但是允许对单元进行某种程度的修改或优化。例如，可以调整单元的尺寸、形状或布局以优化性能，或者删除或添加一些元件以满足特定的功能需求。这种方法的灵活性比纯标准单元设计更高。
  
- LDO cell

  > LDO_CELL **可能**指代 "Low Dropout Voltage Regulator Cell"，即低压差稳压器单元。低压差稳压器通常在集成电路设计中用于提供稳定的电源电压，以满足电路中各个部分对电源电压的要求。在数字电路和模拟电路中，对电源稳定性的要求很高，低压差稳压器在这方面发挥着关键的作用。



#### 2.Pin

- stack pin：

  > "stack pin" 通常指的是一个组合物，其中多个引脚或接触点堆叠在一起。这通常用于电路板设计和集成电路设计中，以优化空间和提高设备的性能和效率。
  >
  > 简单地说，在电路设计中，如果多个器件需要连接到同一节点，就需要使用stack pin。stack pin可以使得这些器件公用一个接触点，节省空间并且提高电路整体的结构性。

#### 3.Wire

> 后端工具里面的wire并不是指Verilog网表里面的wire线型。它是将net物理化的概念，每一条net在后端工具里面是由许多小段的wire组成，每一小段wire我们称之为wire segment，wire有三种类型

- Regular Wire ：信号线，连接着Signal Pin的金属线段。每层金属层上的Regular Wire默认宽度都是一样的。
- Special Wire：电源接地线，平常我们见过的power ring，stripes，power rail等都是Special Wire。一般是用高层金属走线。
- Path Wire：补丁线，这是先进工艺中的一种走线，用于修复Min Area，Min Step等DRC，不属于任何net

#### 4.Net

> 中文名网线，切记不要与Wire混淆，这是一个逻辑概念

#### 5.Layer

> 通常包含多个图层，每个图层用于表示电路中的不同元素或特性。例如，常见的图层包括金属层、多晶硅层、掺杂层等

- Layer Tunnel ：

  > import design最开始的时候，需要设置不同ROUTING布线层之间的tunnel（MENTAL_TYPE_DEVICE不需要），原因可能涉及这几个方面：

  - 电气连接：在不同的图层之间确保电气连接。这可能涉及到通孔（vias）的布局，以确保信号能够在不同的图层之间传递
  - 物理遮蔽： 在一些情况下，某些图层上的元素可能需要被其他图层的元素遮蔽，以阻止某些特定的物理效应。
  - 热连接：在芯片设计中，不同层间的热连接也是一个重要考虑因素。确保热量能够在不同图层之间传递，以维持良好的温度分布
  - 设计规则检查（DRC）：确保布局符合制造工艺的规范。这可能涉及到通孔直径、间距等设计规则的检查

- Layer 类型：

  - CUT（切割层）： 表示晶片的主体区域。CUT 层通常包含电子元件的实际布局，如逻辑门、存储单元等。CUT 层是整个芯片设计的核心。
  - MASTERSLICE（主片层）： 是一种高级层，用于表示电路的主体结构。在ASIC（Application-Specific Integrated Circuit）设计中，MASTERSLICE 层可能包含一些已经完成、被验证的功能模块，设计人员可以将这些模块组合以构建更大的系统。
  - OVERLAP（重叠层）： 通常用于表示在不同图层之间的重叠区域。这在芯片设计中是一个重要的考虑因素，因为不同的物理层可能需要在某些区域进行重叠，例如在通孔区域。
  - ROUTING（布线层）： 用于表示电路的互连或布线。这包括将信号从一个点传输到另一个点的金属线、通孔、连线等。ROUTING 层在芯片设计中起到关键作用，因为它决定了信号的传输路径。
  - NONE（无）： 通常表示空层或未分配层。在某些情况下，设计中的某些区域可能没有分配给任何特定类型的层，因此使用 NONE 表示。

- Layer mental type：

  - MENTAL_TYPE_INTERCONNECT（互连类型）： 这通常用于表示电路中的互连结构，即信号传输的路径，例如金属线、通孔等。在芯片设计中，互连是连接各个元件的关键部分，它决定了信号在芯片中的传输路径。
  - MENTAL_TYPE_DEVICE（设备类型）： 这通常用于表示电路中的实际器件或元器件，例如逻辑门、存储单元等。设备类型涵盖了电路中实际执行逻辑或存储功能的各种组件。





#### 0.other

- PV

  > PV即物理验证，包括DRC（设计规则检查），LVS（版图与原理图一致性检查），ERC（电气规则检查）

- Cell density map / Pin density map

  > Cell density map会将芯片划分成一个个小方块，显示每个方块内cell area和方块area的比值
  >
  > Pin density map是显示每个方块内pin的数量





# 2. git 命令

## 基本命令

- git status : 
  - 看一下当前的状态,列出来哪些文件被修改了，哪些文件是Untracked files
- git branch:
  - 查看本地分支，加上 -a 则显示远程仓库所有分支名

- git show:
  - 相当于看一下文件中都改了哪些内容
- git checkout : 
  - 切换分支 git checkout dev-xiedong
  - 撤销工作区所有文件的更改 git checkout -- . 
  - 撤销工作区某些文件的更改 git checkout -- <filename1> <filename2>
    - 要注意撤销更改的版本，如果还没有git add提交到暂存区的话，此次撤销是从版本库里面恢复，但是如果已经提交到了暂存区，那么就从暂存区恢复内容
- git clean :
  - 从工作目录中删除所有Untracked files
- git commit -m "xxxxxx"
  - 提交的时候可以附带信息
- git commit -a 
  - 把所有tracked改动过的文件全部上传到暂存区
- git reset HEAD~
  - 将最近一次commit的内容，回撤到工作区
- git pull origin dev
  - 表示将远程主机origin上面的dev分支拉取过来，并与本地的分支merge，其实上面完整的命令是：git pull origin dev:dev-xiedong，只不过冒号后面的可以省略。
  - 【注意】：前后是没有空格的
- git push origin dev-xiedong
  - 表示将本地的dev-xiedong分支推送到远程主机origin，因为远程主机里面存在一个跟我本地分支同名的远程分支，因此这里后面就不写了，实际上也要加一个:dev-xiedong
- git branch -d dev-xiedong
  - 删除本地dev-xiedong分支




## 问题总结

- **git push的时候，出现rejected/non-fast-forward错误的解决方式**
  
  - 在自己的当前分支下：
  
  - git pull
  
  - git pull origin dev
  
  - git pull origin dev --allow-unrelated-histories  
  
  - 然后再push自己的分支即可
  
- **commit 之后出现out of date的提示**
  
  - git checkout dev
  - git pull
  - git checkout dev-xiedong
  - git merge dev
  - git pull origin dev
  - git push origin dev-xiedong
  
- **从远程仓库单独拉取某个分支**
  
  1. 本地还没有dev主仓
  
     > `git clone -b dev-xiedong https://github.com/xxx.git`
     >
     > 注意这里会将dev-xiedong分支的代码直接拉到本地，dev主分支的是不会拉取的
  
  2. 本地已有dev主仓
  
     > `git checkout -b dev-xiedong origin/dev-xiedong`
     >
     > 将远程dev-xiedong分支的代码拉取到本地新建的分支dev-xiedong中。
  
  还有一个git fetch的操作，就是将所有远程分支拉到本地，然后git checkout到我们需要的分支，但是分支太多的话不太方便，因此少用。







# 3. Linux命令

## 基础命令

```shell
#在当前目录下的所有文件中的test_run下的icpower.log文件中查找 Merge 关键字  ---注意grep可以在文件中查找
grep Merge */test_run/icpower.log

#-r是递归的意思，这里的意思是在当前文件中的所有项中查找Merge，无论是文件还是文件夹
grep Merge -r * 

#统计目录的总大小，并以可读的方式（以K、M或G为单位）进行表示
du -sh foldername

#在整个系统中查找文件夹folder，-type d表示只搜索文件夹
find / -type d -name "folder"

#查找当前环境变量TMPDIR的值
echo $TMPDIR

#查看自己的端口号
vi ~/ .vnc/ 

#查看当前文件中有多少个文件，find . 会把文件一行行列出来，而 wc -l 这条命令是查看行数，例如 wc -l file1
find . | wc -l

#命令行清空一个文件的内容
truncate -s 0 filename
cp /dev/null filename
echo -n > filename  #echo一个空字符串并重定向到filename，-n是echo参数，表示不要加换行符

#终端里面直接用命令打开文件图形界面
nautilus filename   #ps -ef | grep -i desktop 查看是哪种桌面环境

#scp --两个主机之间发送接收文件
scp xiedong@10.0.1.3:/home/xiedong/test.cpp .  #从远程主机拷贝文件到当前目录
scp text.cpp xiedong@10.0.1.3:/home/xiedong/   #将本地文件拷贝到远程主机

#通过其他server登录当前server -- ssh
ssh xiedong@10.0.1.4

#查看Linux的版本
lsb_release -a

```



## 配置环境

**vim批量添加注释**

```
方法1 小段
    加：vim中 Ctrl+v 选中要加注释的行      Shift+i  插入模式   按Shift+3 = #号       按3次ESC键
    减：vim中 Ctrl+v 选中要减注释的#号      按d  删除
方法2 小段 知道是第几行
    : set number
    加注释#号
    :3,5 s/^/#/g
    减注释#号
    :3,5 s/^#//g

方法3 针对大段
    光标移动到要加注释的行的第一行    .代表当前行  $代表最后一行
    加注释    :.,$ s/^/#/g
    减注释    :.,$ s/^#//g
方法4 针对全部   
    0 代表首行   %通配符 匹配所有行
    加注释    :0,$ s/^/#/g
    减注释    :0,$ s/^#//g
    加注释    :% s/^/#/g
    减注释    :% s/^#//g
```

**vim批量替换**

```shell
:%s/tmp/mpt/g
#将文本中的 tmp 全部替换为 mpt
# %s：表示对整个文件进行替换。
# /tmp/：表示要被替换的文本。
# /mpt/：表示要替换为的文本。
# g：表示全局替换，即一行中的所有匹配都会替换，而不仅仅是第一个匹配。  
```



## 系统信息

```shell
cat /sys/devices/system/cpu/cpu0/cache/index1/coherency_line_size      #查看当前cpu0的cache line大小，x86为64bytes，arm为32bytes
```



# 4. 脚本相关

### 1.关于 || true

```bash
`rm -r filename || true` 这个命令是在Linux或Unix系统中使用的，它包含两个主要部分：`rm -r filename` 和 `|| true`。

1. `rm -r filename`：这是`rm`命令，用于删除文件或目录。`-r`选项表示递归删除，即包括指定目录及其所有子目录和文件。
2. `|| true`：这是Shell中的逻辑操作符，它表示如果前面的命令（在这里是`rm -r filename`）失败（返回非零退出状态），则执行后面的命令（在这里是`true`）。

`true`是一个Shell内置命令，它总是返回零退出状态，表示成功。在这个上下文中，`|| true`的目的是确保即使`rm -r filename`命令失败，整个命令序列也不会导致脚本或Shell会话终止。

这种用法通常是为了避免删除操作失败导致整个脚本或程序中断。例如，如果你尝试删除一个不存在的文件或目录，`rm`命令会返回一个错误。通过使用`|| true`，你可以告诉Shell忽略这个错误并继续执行后面的命令。
```

### 2.  .cshrc文件配置

**切换csh**

从bash切换到csh。 输入：csh

**配置文件**

全局配置文件 /etc/csh.cshrc
个人配置文件 ~/.cshrc或~/.tcshrc

**提示符**

设置一个漂亮使用的的提示符可以让工作变得更愉快高效。
以下是一个合理的配置方案：

```shell
 
if ( $?prompt ) then                                #如果$prompt变量尚未设置，则做如下设置
     if ( "$uid" == "0" ) then                      #判断用户的uid
         set prompt = "%U%n%u@%m [%l] %B%~%b # "    #对于root，我们显示“#”号
     else
         set prompt = "%U%n%u@%m [%l] %B%~%b % "    #对于普通用户，显示“%”号。
     endif
endif
```

**其他常用配置**

```bash
set autolist                 #tab自动补全
set complete=enhance         #自动补全忽略大小写
###########  alias  #################
alias mv 'mv -i'
alias cp 'cp -i'
alias rm 'rm -i'
alias cd 'cd \!*; ls'        #进入目录后，自动显示目录下文件信息
alias .. 'cd ..'
alias h "history"
```



# 5.code coverage

> C++代码的话比较好用的是gcov + lcov，可以集成在cmake中，最后输出html文件，较为直观

```shell
#1. 在最上层父CMakeLists.txt中添加以下命令
    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fprofile-arcs -ftest-coverage")
    SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fprofile-arcs -ftest-coverage")
#2. cmake && make
	#CMake在build 目录内为我们生成了.gcno文件
#3. 归零之前产生的.gcda文件，并初始化并创建基准数据文件
	lcov -d build -z
	lcov -d build -b . --no-external --initial -c -o init.info
#4. 执行要测试的程序
	./run_test #此时生成了在build下.gcno文件所在目录生成了同名.gcda文件
#5. 收集测试文件运行后产生的覆盖率文件
	lcov -d build -b . --no-external -c -o cover.info
#6. 合并基准数据和执行测试文件后生成的覆盖率数据
	lcov -a init.info -a cover.info -o result.info
#7. 过滤不需要关注的源文件路径和信息，支持正则
	lcov --remove total.info '*/usr/include/*' '*/usr/lib/*' \
	'*/usr/lib64/*' '*/usr/local/include/*' '*/usr/local/lib/*' \
	'*/usr/local/lib64/*' '*/third/*' 'testa.cpp' -o final.info
#8. 通过result.info生成html文件
	 genhtml -o final --prefix='pwd' final.info

```

**lcov常用参数**

```shell
-d 项目路径，即.gcda .gcno所在的路径（一般为build）
-b 指定源代码根目录（注意如果要用external的话，这个得加上去）
-a 合并（归并）多个lcov生成的info文件
-c 捕获，也即收集代码运行后所产生的统计计数信息
--no-external 不包括外部库的覆盖率信息（或者说不包括相较于-b源代码根目录的外部目录的覆盖信息）
-i/--initial 初始化所有的覆盖率信息，作为基准数据
-o 生成处理后的文件
-r/--remove 移除不需要关注的覆盖率信息文件
-z 重置所有执行程序所产生的统计信息为0
--prefix html所在文件的位置
```

